## 使用说明
1. 打开.ioc文件，重新生成代码；
2. 打开.touchgfx文件，重新生成代码；
3. 打开MDK工程文件，编译下载运行；

## 架构说明
1. 之前触摸点坐标的获取是通过管脚外部中断获取，这就导致了数据点来得太快，MCU上一个数据都还没处理完，下一个中断就已经来了。。。；
2. 现在的处理逻辑变成了：每获取到一个触摸坐标后，先进行处理，一定要处理完了才区获取下一个坐标点；
3. 获取坐标点的任务优先级一定要比坐标数据处理任务的优先级低，这样就能保证每次一有数据，就能立刻跳转去处理；
4. RTOS中尽量不要阻塞某个任务，多用线程间同步机制；

## 手写识别库说明
1. 手动识别库的头文件`atk_ncr.h`中，定义了最大支持的触摸点`MAX_POINT`；当需要识别的内容越复杂，这个`MAX_POINT`就要越大，占用的内存也就越大；当前例程中设置了`1000`（每个坐标(全局变量`draw_door`)需要`4`个字节存储，所以这里就占用了差不多`40KBytes`的`RAM`空间。。。），对正常的数字字母输入已经绰绰有余了；要是`RAM`比较紧张，可以适当缩小这个值，只要确保正常输入能够识别就好了（不够时例程日志将输出警告）；(如果内存实在紧张，可以尝试将中间一些不那么重要的点去掉，比如直线上均匀删除一些中间点，看看效果；)
2. 手写识别库运行时，会动态分配一些`RAM`，实测最大RAM大约为7KB，可以通过在`alientek_ncr_malloc()`中添加日志统计动态分配的内存；
3. 手写识别库对传入的坐标参数有方向要求，必须传入正着写的坐标数据才能得到正确的结果；倒着写或者旋转90度后，识别错误率大大增加！可通过`RECOGNIZE_TURN_CLOCKWISE`和`RECOGNIZE_TURN_ANTICLOCKWISE`这两个宏定义将触摸坐标进行旋转；
4. 通过编译后的`map`文件可知，`ATKNCR_M_V2.0.lib`占用的`Flash`空间大约为`40KBytes`;
```
      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Library Name
      7104        142      33934         28         40      14307   ATKNCR_M_V2.0.lib
```
5. 综上：这个手写识别库运行至少需要占用大约`20KB`的`RAM`空间，以及`40KB`的`Flash`空间；`STM32F4`系列`168MHz`主频下识别时无明显卡顿现象；